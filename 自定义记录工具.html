<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8"/>
    <title>è®°å½•å·¥å…·</title>
    <link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"/>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script src="https://unpkg.com/element-ui/lib/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuedraggable@2.24.3/dist/vuedraggable.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css/github-markdown.min.css">

    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        #app {
            display: flex;
            height: 100vh;
        }

        .sidebar {
            width: 300px;
            padding: 10px;
            border-right: 1px solid #dcdfe6;
            overflow-y: auto;
            background: #f5f7fa;
        }

        .main {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .remark-input {
            width: 100%;
        }

        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-bottom: 10px;
        }

        .el-button + .el-button,
        .el-checkbox.is-bordered + .el-checkbox.is-bordered {
            margin: 0;
        }
    </style>
</head>
<body>
<div id="app">
    <!-- Sidebar -->
    <div class="sidebar">
        <h3>ğŸ“œ å†å²è®°å½•</h3>
        <div class="button-grid">
            <el-button size="mini" type="info" size="mini" @click="createGroup">â•æ–°å»ºåˆ†ç»„</el-button>
            <el-button type="default" size="mini" @click="drawerVisible = true" size="mini">ğŸ“Š AIåˆ†æ</el-button>
            <el-button icon="el-icon-download" @click="exportData" size="mini" plain>å¯¼å‡ºå¤‡ä»½</el-button>
            <el-button type="default" icon="el-icon-upload" size="mini" @click="$refs.fileInput.click()">å¯¼å…¥æ¢å¤</el-button>
            <input type="file" ref="fileInput" style="display: none" @change="importData" />
            <el-button type="danger" icon="el-icon-delete" @click="clearHistory" size="mini" plain>æ¸…ç©º</el-button>
        </div>
        <el-divider></el-divider>

        <!-- æ›¿æ¢è¿™æ®µ sidebar ä¸­å†å²è®°å½•çš„å±•ç¤ºéƒ¨åˆ† -->
        <!--        <div v-for="(item, index) in history" :key="index"-->
        <!--             style="display: flex; justify-content: space-between; align-items: center;">-->
        <!--            <div @click="loadHistory(index)" style="cursor: pointer; flex: 1;">-->
        <!--                [{{ index + 1 }}] {{ item.remark }}-->
        <!--            </div>-->
        <!--            <el-button icon="el-icon-delete" size="mini" type="text" @click.stop="deleteHistory(index)"></el-button>-->
        <!--        </div>-->
        <div>
            <el-input
                    placeholder="è¾“å…¥å…³é”®å­—è¿›è¡Œè¿‡æ»¤"
                    v-model="filterText">
            </el-input>
            <el-tree
                    ref="tree"
                    :data="treeData"
                    :props="treeProps"
                    node-key="id"
                    default-expand-all
                    draggable
                    :filter-node-method="filterNode"
                    @node-click="onTreeNodeClick"
                    @node-drop="onNodeDrop"
            >
              <span class="custom-tree-node" slot-scope="{ node, data }"
                    style="display: flex; justify-content: space-between; width: 100%;overflow: hidden; align-items: center;">
                <el-tooltip :content="data.label" placement="right" effect="light">
                    <span
                            @dblclick="editTreeLabel(node, data)"
                            style="cursor: pointer;
                         display: inline-block;
                         max-width: 160px;  /* æ ¹æ®éœ€è¦è°ƒæ•´å®½åº¦ */
                         white-space: nowrap;
                         overflow: hidden;
                         text-overflow: ellipsis;"
                    >
                  <template v-if="!data.editing">{{ data.label }}</template>
                  <el-input v-else size="mini" v-model="data.label" @blur="finishEditLabel(data)"
                            @keyup.enter.native="finishEditLabel(data)"/>
                </span>
                </el-tooltip>
<!--                <span>-->
<!--                  <el-button v-if="Array.isArray(data.children)" type="text" size="mini" icon="el-icon-plus"-->
<!--                             @click.stop="addRecordToGroup(data)"></el-button>-->
<!--                    <el-button-->
<!--                            v-if="typeof data.recordIndex === 'number'"-->
<!--                            type="text"-->
<!--                            size="mini"-->
<!--                            icon="el-icon-copy-document"-->
<!--                            @click.stop="copyRecord(data)"-->
<!--                    ></el-button>-->
<!--                  <el-button type="text" size="mini" icon="el-icon-delete"-->
<!--                             @click.stop="deleteTreeNode(data)"></el-button>-->

<!--                </span>-->
                  <!-- Tree èŠ‚ç‚¹å³ä¾§æ“ä½œæŒ‰é’® -->
                <span>
                  <!-- â• ä»…ç”¨äºåˆ†ç»„ -->
                  <el-button
                          v-if="Array.isArray(data.children)"
                          type="text"
                          size="mini"
                          icon="el-icon-plus"
                          @click.stop="addRecordToGroup(data)">
                  </el-button>
                  <el-button
                          v-if="typeof data.recordIndex === 'number'"
                          type="text"
                          size="mini"
                          icon="el-icon-copy-document"
                          @click.stop="copyRecord(data)"
                  ></el-button>
                    <!-- ğŸ—‘ï¸ åˆ é™¤æŒ‰é’®åŠ ç¡®è®¤ popper -->
                  <el-popconfirm
                          title="ç¡®è®¤åˆ é™¤æ­¤é¡¹ï¼Ÿ"
                          confirm-button-text="åˆ é™¤"
                          cancel-button-text="å–æ¶ˆ"
                          icon="el-icon-warning"
                          icon-color="#f56c6c"
                          @confirm="deleteTreeNode(data)">
                    <el-button
                            slot="reference"
                            type="text"
                            size="mini"
                            icon="el-icon-delete"
                            @click.stop>
                    </el-button>
                  </el-popconfirm>
                </span>
              </span>
            </el-tree>
        </div>
    </div>

    <!-- Main Table -->
    <div class="main">
        <el-input v-model="currentRemark" placeholder="è¯·è¾“å…¥æœ¬æ¬¡è®°å½•å¤‡æ³¨" class="remark-input"
                  style="margin-bottom: 10px"></el-input>
        <el-button type="primary" size="mini" @click="columnDrawer = true">åˆ—è®¾ç½®</el-button>
        <el-table height="80vh" :data="tableData" border style="width: 100%; margin-bottom: 10px" :key="tableKey">
            <el-table-column v-for="(col, index) in columns" :key="col._id" align="center" min-width="200"
                             :label="col.label"
                             :prop="col._id">
                <template slot-scope="scope">
                    <!-- æ–‡æœ¬ç±»å‹ -->
                    <el-input v-if="col.type === 'text'" v-model="scope.row[col._id]" size="mini"></el-input>

                    <!-- å¤šè¡Œæ–‡æœ¬ç±»å‹ -->
                    <el-input type="textarea" v-else-if="col.type === 'textarea'" v-model="scope.row[col._id]"
                              size="mini"
                              :autosize="{ minRows: 1, maxRows: 10 }"></el-input>

                    <!-- ä¸‹æ‹‰é€‰æ‹©ç±»å‹ -->
                    <el-select v-else-if="col.type === 'select'" v-model="scope.row[col._id]" size="mini"
                               placeholder="è¯·é€‰æ‹©"
                               style="width: 100%">
                        <el-option v-for="opt in col.options || []" :key="opt" :label="opt" :value="opt"></el-option>
                    </el-select>

                    <!-- å¤šæ ‡ç­¾è¾“å…¥ -->
                    <div v-else-if="col.type === 'tag'"
                         style="display: flex; flex-wrap: wrap; gap: 5px; align-items: center;">
                        <el-tag v-for="(tag, idx) in (scope.row[col._id] || [])" :key="idx" closable
                                @close="scope.row[col._id].splice(idx, 1)" type="primary">
                            {{ tag }}
                        </el-tag>
                        <el-input v-model="tagInput[col._id + '_' + scope.$index]" size="mini" class="tag-input"
                                  placeholder="è¾“å…¥æ ‡ç­¾åå›è½¦"
                                  @keyup.enter.native.prevent="addTag(scope.row, col._id, scope.$index)"
                                  style="width: 120px;"></el-input>
                    </div>
                    <div v-else-if="col.type==='rate'">
                        <el-rate
                                v-model="scope.row[col._id]"
                                :max="5"
                                text-color="#ff9900"
                                show-score
                                allow-half
                                size="small"
                        />
                    </div>
                    <div v-else-if="col.type==='progress'"
                         style="width: 100%; align-items:center;">

                        <div style="width: 100%">
                            <el-progress :percentage="scope.row[col._id]" :color="customColors"></el-progress>
                        </div>
                        <div style="">
                            <el-input-number size="mini" v-model="scope.row[col._id]" :step="5"
                                             controls-position="right" :min="0" :max="100"></el-input-number>
                        </div>
                    </div>
<!--                     å¤šé€‰æ¡†ç±»å‹-->
                    <el-checkbox-group v-else-if="col.type === 'checkbox'" v-model="scope.row[col._id]" size="mini">
                        <el-checkbox style="margin-right: 10px" v-for="opt in col.options || []" :key="opt" :label="opt"
                                     border>{{ opt }}
                        </el-checkbox>
                    </el-checkbox-group>


                    <div v-else-if="col.type === 'date'" style="width: 100%">
                        <!-- date ç±»å‹æ¸²æŸ“ -->
                        <el-date-picker
                                style="width: 80%;"
                                size="mini"
                                v-model="scope.row[col._id]"
                                type="datetime"
                                placeholder="é€‰æ‹©æ—¥æœŸæ—¶é—´"
                                align="right"
                                :picker-options="pickerOptions">
                        </el-date-picker>
                        <div>
                            {{formatDateTime(scope.row[col._id])}}
                        </div>
                    </div>
                    <!-- å…œåº•æ–‡æœ¬è¾“å…¥ -->
                    <el-input v-else v-model="scope.row[col._id]" size="mini"></el-input>
                </template>
            </el-table-column>
            <el-table-column fixed="right" align="center" label="æ“ä½œ" width="80">
                <template slot-scope="scope">
                    <el-button :disabled="scope.$index === 0" icon="el-icon-top" size="mini" @click.stop="moveRow(scope.$index, 'up')" type="text"/>
                    <el-button :disabled="scope.$index === tableData.length - 1" icon="el-icon-bottom" size="mini" @click.stop="moveRow(scope.$index, 'down')" type="text"/>
                    <el-button icon="el-icon-delete" size="mini" @click="removeRow(scope.$index)" type="text"/>
                </template>
            </el-table-column>
        </el-table>

        <el-button type="primary" icon="el-icon-plus" @click="addRow" size="mini">æ·»åŠ è¡Œ</el-button>
        <el-button type="success" icon="el-icon-check" @click="saveRecord" size="mini">ä¿å­˜</el-button>
    </div>

    <!-- Drawer: Column Settings -->
    <el-drawer title="åˆ—è®¾ç½®" :visible.sync="columnDrawer" direction="rtl" size="30%">
        <div style="padding: 10px;">
            <el-form @submit.native.prevent>
                <el-form-item label="åˆ—å">
                    <el-input v-model="newColumn.label" placeholder="å¦‚ï¼šç­‰çº§"/>
                </el-form-item>
                <el-form-item label="ç±»å‹">
                    <el-select v-model="newColumn.type" placeholder="è¯·é€‰æ‹©ç±»å‹">
                        <el-option label="æ–‡æœ¬" value="text"></el-option>
                        <el-option label="å¤šè¡Œæ–‡æœ¬" value="textarea"></el-option>
                        <el-option label="ä¸‹æ‹‰é€‰æ‹©" value="select"></el-option>
                        <el-option label="æ ‡ç­¾" value="tag"></el-option>
                        <el-option label="å¤šé€‰æ¡†" value="checkbox"></el-option>
                        <el-option label="æ˜Ÿçº§è¯„åˆ†" value="rate"></el-option>
                        <el-option label="è¿›åº¦æ¡" value="progress"></el-option>
                        <el-option label="æ—¥æœŸ" value="date"></el-option>
                    </el-select>
                </el-form-item>
                <el-form-item v-if="newColumn.type === 'select'" label="é€‰é¡¹ï¼ˆé€—å·åˆ†éš”ï¼‰">
                    <el-input v-model="newColumn.optionsText" placeholder="ä¾‹å¦‚ï¼šçº¢,ç»¿,è“"/>
                </el-form-item>

                <el-button type="primary" @click="confirmAddColumn">ç¡®è®¤æ·»åŠ </el-button>
            </el-form>

            <el-divider>å½“å‰åˆ—ï¼ˆå¯æ‹–åŠ¨æ’åºï¼‰</el-divider>
            <!-- æ›¿æ¢ drawer ä¸­ columns è®¾ç½®çš„æ¯é¡¹å±•ç¤ºé€»è¾‘ -->
            <draggable v-model="columns" :options="{ handle: '.drag-handle' }" @end="updateTableKey">
                <div v-for="(col, i) in columns" :key="col._id"
                     style="margin-bottom: 5px; display: flex; flex-direction: column; gap: 4px;">

                    <!-- æ–°å¢ç±»å‹æ˜¾ç¤º -->
                    <div style="font-size: 12px; color: #909399; user-select: none;">
                        ç±»å‹: <strong>{{ typeLabel(col.type) }}</strong>
                    </div>
                    <div style="display: flex; align-items: center; gap: 5px;">
                        <el-input v-model="col.label" size="mini" placeholder="åˆ—å"
                                  @blur="validateAndUpdateColumn(i)"></el-input>
                        <el-button icon="el-icon-rank" type="text" class="drag-handle" size="mini"></el-button>
                        <el-button icon="el-icon-delete" @click="removeColumn(i)" type="text" size="mini"></el-button>
                    </div>
                    <div v-if="col.type === 'select' || col.type === 'checkbox'">
                        <el-input placeholder="é€‰é¡¹ï¼ˆé€—å·åˆ†éš”ï¼‰" v-model="col.optionsText" size="mini"
                                  @input="updateSelectOptions(i, col.optionsText)"></el-input>
                    </div>
                </div>
            </draggable>
        </div>
    </el-drawer>
    <el-drawer
            :title="`AI åˆ†æç»“æœ, å½“å‰è®°å½•:${selectedRecord?.remark || ''}`"
            :visible.sync="drawerVisible"
            size="90%"
            direction="btt"
    >

        <div style="padding: 30px">
            <el-form size="mini" label-width="80px">
                <el-row>
                    <el-col :span="6">
                        <el-form-item label="AIç±»å‹">
                            <el-select v-model="ai.path" placeholder="è¯·é€‰æ‹©ç±»å‹">
                                <el-option v-for="item in aiType" :label="item.name" :value="item.url"></el-option>
                            </el-select>
                        </el-form-item>
                    </el-col>
                    <el-col :span="6">

                       <el-form-item label="API-Key">
                           <el-input v-model="ai.key"></el-input>
                       </el-form-item>
                    </el-col>
                </el-row>
                <el-row>
                    <el-col :span="24">
                        <el-form-item label="å¯¹è¯å†…å®¹">
                            <el-input placeholder="è¯·è¾“å…¥, å¦åˆ™åªä¼šå‘é€å¯¹åº”æ•°æ®ç»™DeepSeek;  æš‚ä¸æ”¯æŒå¤šè½®å¯¹è¯" v-model="condition" type="textarea"></el-input>
                        </el-form-item>
                    </el-col>
                </el-row>
                <el-row>
                    <el-col :span="24">
                        <el-form-item>
                            </el-form-item>
                    </el-col>
                </el-row>
            </el-form>
            <el-button :disabled="aiLoading" v-loading="aiLoading" element-loading-text="AIè¾“å‡ºä¸­" element-loading-spinner="el-icon-loading" style="margin-left: 30px" type="default" size="mini" @click="analyzeData" size="mini">å¼€å§‹åˆ†æ</el-button>
            <div class="markdown-body" v-html="renderedMarkdown" style="margin: 30px; padding: 10px; overflow-y: scroll; height: 50vh;border: #909399 1px solid;border-radius: 10px"></div>

        </div>

    </el-drawer>
</div>

<!-- Vue Script -->
<script>
    Vue.component("draggable", vuedraggable);

    new Vue({
        el: "#app",
        data() {
            return {
                groupedHistory: [],
                currentRecordIndex: null,
                selectedRecord: null,
                aiLoading: false,
                aiResult: '',
                filterText: '',
                condition: '',
                treeData: [],
                aiType: [
                    {
                        name: 'DeepSeek',
                        url: 'https://api.deepseek.com/chat/completions'
                    }
                ],
                ai: {
                  path: '',
                  key: ''
                },
                treeProps: {children: 'children', label: 'label'},
                selectedGroupId: null,
                columns: [],
                apiKey: '',
                newColumn: {
                    label: "",
                    type: "text",
                    optionsText: ""
                },
                pickerOptions: {
                    shortcuts: [{
                        text: 'ä»Šå¤©',
                        onClick(picker) {
                            picker.$emit('pick', new Date());
                        }
                    }, {
                        text: 'æ˜¨å¤©',
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24);
                            picker.$emit('pick', date);
                        }
                    }, {
                        text: 'ä¸€å‘¨å‰',
                        onClick(picker) {
                            const date = new Date();
                            date.setTime(date.getTime() - 3600 * 1000 * 24 * 7);
                            picker.$emit('pick', date);
                        }
                    }]
                },
                customColors: [
                    {color: '#f56c6c', percentage: 20},
                    {color: '#e6a23c', percentage: 40},
                    {color: '#5cb87a', percentage: 60},
                    {color: '#1989fa', percentage: 80},
                    {color: '#6f7ad3', percentage: 100}
                ],
                columnDrawer: false,
                drawerVisible: false,
                tableData: [],
                history: [],
                currentIndex: null,
                currentRemark: "",
                storageKey: "dnf_material_history_v3",
                tagInput: {},
                progress: 0,
                tableKey: Date.now()
            };
        },
        computed: {
            renderedMarkdown() {
                console.log(window)
                return window.marked.marked(this.aiResult || '');
            }
        },
        watch: {
            filterText(val) {
                this.$refs.tree.filter(val);
            }
        },
        created() {
            this.loadHistoryFromStorage();
        },
        methods: {
            onNodeDrop(draggingNode, dropNode, dropType, ev) {
                const dragData = draggingNode.data;
                const dropData = dropNode.data;

                // åªå¤„ç†è®°å½•èŠ‚ç‚¹æ‹–åŠ¨åˆ°åˆ†ç»„èŠ‚ç‚¹
                if (typeof dragData.recordIndex === 'number' && dropData.children) {
                    const fromGroup = this.groupedHistory.find(g => g.id === dragData.groupId);
                    const toGroup = this.groupedHistory.find(g => g.id === dropData.id);
                    if (!fromGroup || !toGroup) return;

                    // å–å‡ºæ‹–æ‹½è®°å½•
                    const record = fromGroup.children.splice(dragData.recordIndex, 1)[0];
                    // æ’å…¥ç›®æ ‡åˆ†ç»„æœ«å°¾
                    toGroup.children.push(record);

                    this.saveHistoryToStorage();
                    this.buildTree();
                    this.$message.success("è®°å½•å·²ç§»åŠ¨");
                } else {
                    this.$message.warning("åªå…è®¸ç§»åŠ¨è®°å½•åˆ°åˆ†ç»„");
                }
            },
            copyRecord(data) {
                const group = this.groupedHistory.find(g => g.id === data.groupId);
                if (!group) return;

                const record = group.children[data.recordIndex];
                if (!record) return;

                // æ·±æ‹·è´è®°å½•
                const newRecord = JSON.parse(JSON.stringify(record));

                // æ’å…¥åˆ°åŒä¸€ä¸ªåˆ†ç»„æœ«å°¾
                group.children.push(newRecord);
                newRecord.remark = newRecord.remark?.split("#")[0] + '#' + this.getRandomValues()
                this.saveHistoryToStorage();
                this.buildTree();
                this.$message.success("è®°å½•å·²å¤åˆ¶");
            },
            filterNode(value, data) {
                if (!value) return true;
                return data.label.indexOf(value) !== -1;
            },
            createGroup() {
                const id = 'group_' + Date.now();
                this.groupedHistory.push({id, name: 'æ–°åˆ†ç»„', children: []});
                this.saveHistoryToStorage();
                this.buildTree();
            },
            addRecordToGroup(group) {
                this.columns = [];
                this.tableData = [];
                this.currentRemark = '';
                this.selectedGroupId = group.id;
                this.currentRecordIndex = null;  // æ–°å¢ï¼Œæ ‡æ˜æ˜¯æ–°å¢è®°å½•
            },
            saveRecord() {
                if (!this.selectedGroupId) {
                    this.$message.error("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªåˆ†ç»„");
                    return;
                }

                debugger
                const group = this.groupedHistory.find(g => g.id === this.selectedGroupId);
                if (!group) return;

                const newRecord = {
                    remark: this.currentRemark,
                    columns: JSON.parse(JSON.stringify(this.columns)),
                    data: JSON.parse(JSON.stringify(this.tableData))
                };

                if (typeof this.currentRecordIndex === 'number') {
                    // âœ… æ›´æ–°å·²æœ‰è®°å½•
                    this.$set(group.children, this.currentRecordIndex, newRecord);
                    this.$message.success("è®°å½•å·²æ›´æ–°");
                } else {
                    // âœ… æ–°å¢è®°å½•
                    group.children.push(newRecord);
                    this.$message.success("è®°å½•å·²ä¿å­˜åˆ°åˆ†ç»„");
                }

                this.saveHistoryToStorage();
                this.buildTree();
            },
            addColumn() {
                const id = 'col_' + Date.now();
                const label = prompt("è¯·è¾“å…¥åˆ—å", "åˆ—");
                if (!label) return;
                this.columns.push({id, label});
                this.tableData.forEach(row => this.$set(row, id, ''));
            },
            addRow() {
                // const row = {};
                // this.columns.forEach(c => row[c.id] = '');
                this.tableData.push(this.emptyRow());
                // this.emptyRow()
            },
            buildTree() {
                this.treeData = this.groupedHistory.map(group => ({
                    id: group.id,
                    label: group.name,
                    editing: false,
                    children: group.children.map((rec, idx) => ({
                        id: group.id + '_rec_' + idx,
                        label: `[${idx + 1}] ${rec.remark || 'æœªå‘½å'}`,
                        groupId: group.id,
                        recordIndex: idx
                    }))
                }));
            },
            onTreeNodeClick(data) {
                if (typeof data.recordIndex === 'number') {
                    const group = this.groupedHistory.find(g => g.id === data.groupId);
                    const record = group?.children[data.recordIndex];
                    if (!record) return;
                    this.columns = JSON.parse(JSON.stringify(record.columns));
                    this.tableData = JSON.parse(JSON.stringify(record.data));
                    this.currentRemark = record.remark;
                    this.selectedGroupId = group.id;
                    this.currentRecordIndex = data.recordIndex; // è®¾ç½®å½“å‰æ­£åœ¨ç¼–è¾‘çš„è®°å½•ç´¢å¼•
                    this.selectedRecord = record; // âœ… æ–°å¢è¿™å¥
                } else {
                    // this.selectedGroupId = data.id;
                    // this.currentRecordIndex = null; // ä¸æ˜¯è®°å½•ï¼Œåªæ˜¯ç‚¹å‡»äº†åˆ†ç»„
                }
            },
            deleteTreeNode(data) {
                if (typeof data.recordIndex === 'number') {
                    const group = this.groupedHistory.find(g => g.id === data.groupId);
                    group?.children.splice(data.recordIndex, 1);
                } else {
                    this.groupedHistory = this.groupedHistory.filter(g => g.id !== data.id);
                }
                this.saveHistoryToStorage();
                this.buildTree();
            },
            editTreeLabel(node, data) {
                if (!data.children) {
                    return
                }
                this.$set(data, 'editing', true);
            },
            finishEditLabel(data) {
                data.editing = false;
                const group = this.groupedHistory.find(g => g.id === data.id);
                if (group) group.name = data.label;
                this.saveHistoryToStorage();
            },
            saveHistoryToStorage() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.groupedHistory));
            },
            loadHistoryFromStorage() {
                try {
                    this.groupedHistory = JSON.parse(localStorage.getItem(this.storageKey) || '[]');
                    this.buildTree();
                } catch {
                    this.groupedHistory = [];
                }
            },
            typeLabel(type) {
                const map = {
                    text: "æ–‡æœ¬",
                    textarea: "å¤šè¡Œæ–‡æœ¬",
                    select: "ä¸‹æ‹‰é€‰æ‹©",
                    tag: "æ ‡ç­¾",
                    progress: "è¿›åº¦æ¡",
                    rate: "æ˜Ÿçº§è¯„åˆ†",
                    date: "æ—¥æœŸæ—¶é—´",
                    checkbox: "å¤šé€‰æ¡†"
                };
                return map[type] || "æœªçŸ¥ç±»å‹";
            },
            updateTableKey() {
                this.tableKey = Date.now(); // æ¯æ¬¡è®¾ç½®ä¸€ä¸ªä¸åŒçš„ key å€¼è§¦å‘é‡æ–°æ¸²æŸ“
            },
            addTag(row, colId, rowIndex) {
                const key = colId + "_" + rowIndex;
                let val = this.tagInput[key];
                if (!val) return;
                val = val.trim();
                if (!val) return;

                if (!Array.isArray(row[colId])) {
                    this.$set(row, colId, []);
                }
                if (!row[colId].includes(val)) {
                    row[colId].push(val);
                }
                this.$set(this.tagInput, key, "");
            },
            generateColId() {
                return 'col_' + this.getRandomValues();
            },
            getRandomValues() {
                return Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 8)
            },
            newRecord() {
                this.columns.splice(0);
                this.tableData.splice(0);
                this.currentIndex = null;
                this.currentRemark = "";
                this.tagInput = {};
            },
            moveRow(index, direction) {
                const data = [...this.tableData]; // æ–°æ•°ç»„æ›¿æ¢å¼•ç”¨

                if (direction === 'up' && index > 0) {
                    [data[index - 1], data[index]] = [data[index], data[index - 1]];
                } else if (direction === 'down' && index < data.length - 1) {
                    [data[index], data[index + 1]] = [data[index + 1], data[index]];
                }

                this.tableData = data; // æ›¿æ¢å¼•ç”¨è§¦å‘è§†å›¾æ›´æ–°
            },
            removeRow(index) {
                this.tableData.splice(index, 1);
                Object.keys(this.tagInput).forEach(key => {
                    if (key.endsWith('_' + index)) {
                        delete this.tagInput[key];
                    }
                });
            },
            confirmAddColumn() {
                const label = this.newColumn.label.trim();
                if (!label) return;
                if (this.columns.find((c) => c.label === label)) {
                    this.$message.error("åˆ—åä¸èƒ½é‡å¤");
                    return;
                }
                const id = this.generateColId();
                const type = this.newColumn.type || "text";
                const column = {
                    label,
                    type,
                    _id: id
                };
                if (type === "select" || type === "checkbox") {
                    column.options = this.newColumn.optionsText.split(",").map((s) => s.trim()).filter((s) => s);
                    column.optionsText = this.newColumn.optionsText;
                }
                this.columns.push(column);

                this.tableData.forEach(row => {
                    if (column.type === 'tag' || column.type === 'checkbox') {
                        this.$set(row, id, []);
                    } else if (column.type === 'rate' || column.type === 'progress') {
                        this.$set(row, id, 0);
                    } else {
                        this.$set(row, id, "");
                    }
                });

                this.newColumn = {
                    label: "",
                    type: "text",
                    optionsText: ""
                };
            },
            removeColumn(index) {
                const col = this.columns[index];
                this.columns.splice(index, 1);
                this.tableData.forEach((row) => {
                    this.$delete(row, col._id);
                });
            },
            emptyRow() {
                const row = {};
                this.columns.forEach((col) => {
                    if (col.type === 'tag' || col.type === 'checkbox') {
                        row[col._id] = [];
                    } else if (col.type === 'select') {
                        row[col._id] = ""; // ä¸‹æ‹‰é»˜è®¤ç©ºå­—ç¬¦ä¸²
                    } else if (col.type === 'rate' || col.type === 'progress') {
                        row[col._id] = 0;
                    } else {
                        row[col._id] = ""; // å…¶ä»–ç±»å‹é»˜è®¤ç©ºå­—ç¬¦ä¸²
                    }


                });
                return row;
            },

            syncOptionsTextToColumns() {
                this.columns.forEach(col => {
                    if (col.type === 'select' || col.type === 'checkbox') {
                        col.optionsText = (col.options || []).join(',');
                    }
                });
            },

            formatDateTime(isoString) {
                if (!isoString) {
                    return "";
                }
                const date = new Date(isoString)

                const pad = n => n.toString().padStart(2, '0')

                const year = date.getFullYear()
                const month = pad(date.getMonth() + 1)
                const day = pad(date.getDate())
                const hours = pad(date.getHours())
                const minutes = pad(date.getMinutes())
                const seconds = pad(date.getSeconds())

                return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`
            },
            clearHistory() {
                this.$confirm(
                    'æ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰å†å²è®°å½•ï¼Œä¸”æ— æ³•æ¢å¤ã€‚è¯·ç¡®è®¤æ˜¯å¦å·²å®Œæˆæ•°æ®å¤‡ä»½ï¼Ÿ',
                    'è­¦å‘Š',
                    {
                        confirmButtonText: 'æˆ‘å·²å¤‡ä»½ï¼Œæ¸…ç©º',
                        cancelButtonText: 'å–æ¶ˆ',
                        type: 'warning'
                    }
                ).then(() => {
                    this.groupedHistory = [];
                    this.treeData = [];
                    this.columns = [];
                    this.tableData = [];
                    this.currentRemark = '';
                    this.selectedGroupId = null;
                    this.saveHistoryToStorage();
                    this.$message.success('å†å²è®°å½•å·²æ¸…ç©º');
                }).catch(() => {
                    this.$message.info('å·²å–æ¶ˆæ¸…é™¤');
                });
            },
            exportData() {
                const dataStr = JSON.stringify(this.groupedHistory, null, 2);
                const blob = new Blob([dataStr], {
                    type: "application/json"
                });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = `diy_record_data_backup_${this.formatDateTime(new Date().getTime())}.json`;
                a.click();
                URL.revokeObjectURL(url);
            },
            importData(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const imported = JSON.parse(event.target.result);
                        if (!Array.isArray(imported)) {
                            this.$message.error("å¯¼å…¥çš„æ•°æ®æ ¼å¼ä¸æ­£ç¡®");
                            return;
                        }

                        this.groupedHistory = imported;
                        this.saveHistoryToStorage();
                        this.buildTree();
                        this.$message.success("å¯¼å…¥æˆåŠŸ");

                    } catch (err) {
                        this.$message.error("å¯¼å…¥å¤±è´¥ï¼Œæ–‡ä»¶å¯èƒ½ä¸æ˜¯æœ‰æ•ˆçš„ JSON");
                    }
                };
                reader.readAsText(file);
                // æ¸…ç©º input çš„å€¼ï¼Œé¿å…é‡å¤å¯¼å…¥åŒä¸€ä¸ªæ–‡ä»¶ä¸ä¼šè§¦å‘ change äº‹ä»¶
                e.target.value = null;
            },
            // summarize(data) {
            //     if (!data || !data.length) return "";
            //     const firstRow = data[0];
            //     if (!firstRow) return "";
            //     const firstKey = Object.keys(firstRow)[0];
            //     if (!firstKey) return "";
            //     return firstRow[firstKey];
            // },
            // handleTagEnter(row, colId, rowIndex) {
            //     const key = colId + "_" + rowIndex;
            //     let val = this.tagInput[key];
            //     if (!val) return;
            //     val = val.trim();
            //     if (!val) return;
            //     this.$set(row, colId, val);
            //     this.$set(this.tagInput, key, "");
            // },
            validateAndUpdateColumn(index) {
                const col = this.columns[index];
                if (!col.label.trim()) {
                    this.$message.error("åˆ—åä¸èƒ½ä¸ºç©º");
                    col.label = "æœªå‘½ååˆ—";
                }
                const duplicates = this.columns.filter((c, i) => c.label === col.label && i !== index);
                if (duplicates.length) {
                    this.$message.error("åˆ—åä¸èƒ½é‡å¤");
                    col.label = col.label + "(é‡å¤)";
                }
            },
            updateSelectOptions(index, optionsText) {
                this.columns[index].options = optionsText.replace("ï¼Œ", ",").split(",").map(s => s.trim()).filter(s => s);
            },
            async analyzeData0() {
                if (!this.selectedRecord) {
                    this.$message.warning("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè®°å½•");
                    return;
                }

                const { columns, data } = this.selectedRecord;

                const rows = data.map((row, i) => {
                    const rowStr = columns.map(col => `${col.label}: ${row[col._id]}`).join(', ');
                    return `ç¬¬ ${i + 1} è¡Œï¼š${rowStr}`;
                }).join('\n');

                const prompt = `è¯·å¯¹ä»¥ä¸‹è®°å½•æ•°æ®è¿›è¡Œåˆ†æï¼Œå¹¶ç»™å‡ºè¶‹åŠ¿å’Œå»ºè®®ï¼š\n${rows}`;

                try {
                    const res = await axios.post('https://api.deepseek.com/chat/completions', {
                        model: 'deepseek-chat',
                        messages: [
                            { role: 'user', content: prompt }
                        ]
                    }, {
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.ai.key}`
                        }
                    });

                    const reply = res.data.choices?.[0]?.message?.content;
                    this.aiResult = reply || "æ— å†…å®¹è¿”å›";
                } catch (err) {
                    console.error(err);
                    this.$message.error("AI åˆ†æå¤±è´¥");
                }
            },
            async analyzeData() {
                if (!this.selectedRecord) {
                    this.$message.warning("è¯·å…ˆé€‰æ‹©ä¸€ä¸ªè®°å½•");
                    return;
                }
                this.aiLoading = true;

                const { columns, data } = this.selectedRecord;
                const rows = data.map((row, i) => {
                    const rowStr = columns.map(col => `${col.label}: ${row[col._id]}`).join(', ');
                    return `ç¬¬ ${i + 1} è¡Œï¼š${rowStr}`;
                }).join('\n');

                const prompt = `è¯·å¯¹ä»¥ä¸‹è®°å½•æ•°æ®è¿›è¡Œåˆ†æï¼š\n${rows}`;

                this.aiResult = "åˆ†æä¸­ï¼Œè¯·ç¨å€™...\n"; // æ¸…ç©ºæ—§å†…å®¹
                try {
                    const res = await fetch(this.ai.path, {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            "Authorization": `Bearer ${this.ai.key}`,
                            "Accept": "text/event-stream"
                        },
                        body: JSON.stringify({
                            model: "deepseek-chat",
                            stream: true,
                            messages: [{ role: "user", content: prompt },
                                { role: "user", content: this.condition }]
                        })
                    });

                    const reader = res.body.getReader();
                    const decoder = new TextDecoder("utf-8");
                    let partial = "";
                    this.aiResult = ''
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) {
                            this.aiLoading = false
                            break;
                        }

                        const chunk = decoder.decode(value, { stream: true });
                        partial += chunk;

                        // è§£æ SSE äº‹ä»¶
                        const lines = partial.split('\n');
                        partial = lines.pop(); // incomplete line cache

                        for (let line of lines) {
                            if (line.startsWith("data: ")) {
                                const payload = line.slice(6).trim();
                                if (payload === "[DONE]") break;

                                const json = JSON.parse(payload);
                                const delta = json.choices?.[0]?.delta?.content;
                                if (delta) {
                                    this.aiResult += delta; // å¢é‡è¿½åŠ 
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.error(err);
                    this.aiLoading = false
                    this.$message.error("AIæµå¼åˆ†æå¤±è´¥");
                }
            }
        }
    });
</script>
</body>
</html>
